package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"time"

	"github.com/JakeHolcombe16/Cloud-Distributed-Transcode-Pipeline/apps/graphql/internal/db"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

// Jobs is the resolver for the jobs field.
func (r *queryResolver) Jobs(ctx context.Context, limit *int, offset *int, status *JobStatus) ([]*Job, error) {
	// Set defaults
	limitVal := int32(50)
	offsetVal := int32(0)
	if limit != nil {
		limitVal = int32(*limit)
	}
	if offset != nil {
		offsetVal = int32(*offset)
	}

	var dbJobs []db.Job
	var err error

	if status != nil {
		// Map GraphQL status to DB status
		dbStatus := mapGraphQLStatusToDB(*status)
		dbJobs, err = r.DB.ListJobsByStatus(ctx, db.ListJobsByStatusParams{
			Status: dbStatus,
			Limit:  limitVal,
			Offset: offsetVal,
		})
	} else {
		dbJobs, err = r.DB.ListJobs(ctx, db.ListJobsParams{
			Limit:  limitVal,
			Offset: offsetVal,
		})
	}

	if err != nil {
		return nil, err
	}

	// Convert to GraphQL types
	jobs := make([]*Job, len(dbJobs))
	for i, dbJob := range dbJobs {
		jobs[i], err = r.convertJob(ctx, dbJob)
		if err != nil {
			return nil, err
		}
	}

	return jobs, nil
}

// Job is the resolver for the job field.
func (r *queryResolver) Job(ctx context.Context, id string) (*Job, error) {
	jobUUID, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}

	pgUUID := pgtype.UUID{
		Bytes: jobUUID,
		Valid: true,
	}

	dbJob, err := r.DB.GetJob(ctx, pgUUID)
	if err != nil {
		return nil, err
	}

	return r.convertJob(ctx, dbJob)
}

// SystemMetrics is the resolver for the systemMetrics field.
func (r *queryResolver) SystemMetrics(ctx context.Context) (*SystemMetrics, error) {
	// Get job counts from database
	counts, err := r.DB.CountJobsByStatus(ctx)
	if err != nil {
		return nil, err
	}

	// Get queue depth from Redis
	queueDepth, err := r.RedisClient.LLen(ctx, "jobs:pending").Result()
	if err != nil {
		// Log error but don't fail - queue depth is supplementary
		queueDepth = 0
	}

	return &SystemMetrics{
		QueueDepth:     int(queueDepth),
		TotalJobs:      int(counts.Total),
		CompletedJobs:  int(counts.Completed),
		FailedJobs:     int(counts.Failed),
		ProcessingJobs: int(counts.Processing),
	}, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *queryResolver) convertJob(ctx context.Context, dbJob db.Job) (*Job, error) {
	// Get renditions for this job
	dbRenditions, err := r.DB.GetRenditionsByJobID(ctx, dbJob.ID)
	if err != nil {
		return nil, err
	}

	renditions := make([]*Rendition, len(dbRenditions))
	for i, dbRend := range dbRenditions {
		renditions[i] = &Rendition{
			ID:         uuidToString(dbRend.ID),
			Resolution: dbRend.Resolution,
			OutputKey:  pgtextToStringPtr(dbRend.OutputKey),
		}
	}

	return &Job{
		ID:           uuidToString(dbJob.ID),
		Status:       mapDBStatusToGraphQL(dbJob.Status),
		InputKey:     dbJob.InputKey,
		ErrorMessage: pgtextToStringPtr(dbJob.ErrorMessage),
		CreatedAt:    dbJob.CreatedAt.Time,
		UpdatedAt:    dbJob.UpdatedAt.Time,
		Renditions:   renditions,
	}, nil
}
func uuidToString(u pgtype.UUID) string {
	if !u.Valid {
		return ""
	}
	return uuid.UUID(u.Bytes).String()
}
func pgtextToStringPtr(t pgtype.Text) *string {
	if !t.Valid {
		return nil
	}
	return &t.String
}
func mapGraphQLStatusToDB(status JobStatus) db.JobStatus {
	switch status {
	case JobStatusPending:
		return db.JobStatusQueued
	case JobStatusProcessing:
		return db.JobStatusProcessing
	case JobStatusCompleted:
		return db.JobStatusCompleted
	case JobStatusFailed:
		return db.JobStatusFailed
	default:
		return db.JobStatusQueued
	}
}
func mapDBStatusToGraphQL(status db.JobStatus) JobStatus {
	switch status {
	case db.JobStatusQueued:
		return JobStatusPending
	case db.JobStatusProcessing:
		return JobStatusProcessing
	case db.JobStatusCompleted:
		return JobStatusCompleted
	case db.JobStatusFailed:
		return JobStatusFailed
	default:
		return JobStatusPending
	}
}

type DateTime = time.Time
